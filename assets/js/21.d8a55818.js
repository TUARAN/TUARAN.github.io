(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{515:function(s,n,a){"use strict";a.r(n);var t=a(2),r=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"掘金小册"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#掘金小册"}},[s._v("#")]),s._v(" 掘金小册")]),s._v(" "),a("h3",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[s._v("#")]),s._v(" 数组")]),s._v(" "),a("ul",[a("li",[s._v("数组操作")])]),s._v(" "),a("h3",{attrs:{id:"栈、队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈、队列"}},[s._v("#")]),s._v(" 栈、队列")]),s._v(" "),a("ul",[a("li",[s._v("栈：后进先出。push()、pop()")]),s._v(" "),a("li",[s._v("队列：先进先出。push()、shift()")])]),s._v(" "),a("h3",{attrs:{id:"链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[s._v("#")]),s._v(" 链表")]),s._v(" "),a("p",[s._v("链表的插入/删除效率较高，而访问效率较低；数组的访问效率较高，而插入效率较低。")]),s._v(" "),a("h3",{attrs:{id:"二叉树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[s._v("#")]),s._v(" 二叉树")]),s._v(" "),a("ul",[a("li",[s._v("度")]),s._v(" "),a("li",[s._v("二叉树的定义")])]),s._v(" "),a("h3",{attrs:{id:"前中后序遍历"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前中后序遍历"}},[s._v("#")]),s._v(" 前中后序遍历")]),s._v(" "),a("ul",[a("li",[s._v("根结点 -> 左子树 -> 右子树//前序")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 所有遍历函数的入参都是树的根结点对象\nfunction preorder(root) {\n    // 递归边界，root 为空\n    if(!root) {\n        return \n    }\n     \n    // 输出当前遍历的结点值\n    console.log('当前遍历的结点值是：', root.val)  \n    // 递归遍历左子树 \n    preorder(root.left)  \n    // 递归遍历右子树  \n    preorder(root.right)\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("ul",[a("li",[s._v("左子树 -> 根结点 -> 右子树//中序")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 所有遍历函数的入参都是树的根结点对象\nfunction inorder(root) {\n    // 递归边界，root 为空\n    if(!root) {\n        return \n    }\n     \n    // 递归遍历左子树 \n    inorder(root.left)  \n    // 输出当前遍历的结点值\n    console.log('当前遍历的结点值是：', root.val)  \n    // 递归遍历右子树  \n    inorder(root.right)\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("ul",[a("li",[s._v("左子树 -> 右子树 -> 根结点//后序")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function postorder(root){\n    if(!root){\n        return;\n    }\n    postorder(root.left)\n    postorder(root.right)\n    console.log('当前遍历的结点值是：', root.val)\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h3",{attrs:{id:"时间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[s._v("#")]),s._v(" 时间复杂度")]),s._v(" "),a("p",[s._v("运行次数")]),s._v(" "),a("h3",{attrs:{id:"空间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度"}},[s._v("#")]),s._v(" 空间复杂度")]),s._v(" "),a("p",[s._v("所占内存")]),s._v(" "),a("p",[s._v("常见的空间复杂度有 O(1)、O(n) 和 O(n^2)。")]),s._v(" "),a("h3",{attrs:{id:"出题方向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#出题方向"}},[s._v("#")]),s._v(" 出题方向")]),s._v(" "),a("p",[s._v("数组题目要想往难了出，基本都要结合排序、二分和动态规划这些相对复杂的算法思想才行。")]),s._v(" "),a("h3",{attrs:{id:"两数之和"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#两数之和"}},[s._v("#")]),s._v(" 两数之和")]),s._v(" "),a("h3",{attrs:{id:"合并两个有序数组-双指针解法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合并两个有序数组-双指针解法"}},[s._v("#")]),s._v(" 合并两个有序数组（双指针解法）")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("示例: 输入:\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6], n = 3\n输出: [1,2,2,3,5,6]\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nconst merge = function(nums1, m, nums2, n) {\n    // 初始化两个指针的指向，初始化 nums1 尾部索引k\n    let i = m - 1, j = n - 1, k = m + n - 1\n    // 当两个数组都没遍历完时，指针同步移动\n    while(i >= 0 && j >= 0) {\n        // 取较大的值，从末尾往前填补\n        if(nums1[i] >= nums2[j]) {\n            nums1[k] = nums1[i] \n            i-- \n            k--\n        } else {\n            nums1[k] = nums2[j] \n            j-- \n            k--\n        }\n    }\n    \n    // nums2 留下的情况，特殊处理一下 \n    while(j>=0) {\n        nums1[k] = nums2[j]  \n        k-- \n        j--\n    }\n};\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br")])]),a("h3",{attrs:{id:"对撞指针"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对撞指针"}},[s._v("#")]),s._v(" 对撞指针")]),s._v(" "),a("p",[s._v("看到“有序”和“数组”。立刻把双指针法调度进你的大脑内存。普通双指针走不通，立刻想对撞指针！")]),s._v(" "),a("h3",{attrs:{id:"回文、对称性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回文、对称性"}},[s._v("#")]),s._v(" 回文、对称性")]),s._v(" "),a("h3",{attrs:{id:"链表-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链表-2"}},[s._v("#")]),s._v(" 链表")]),s._v(" "),a("p",[s._v("数组、字符串：数组和字符串的角色往往是“算法思想的载体”，若想往难了出，那一定是要结合一些超越数据结构本身的东西——比如排序算法、二分思想、动态规划思想等等")]),s._v(" "),a("p",[s._v("链表本身就可以被认为是“命题的目的”。链表的删除是重点中的重点！")])])}),[],!1,null,null,null);n.default=r.exports}}]);