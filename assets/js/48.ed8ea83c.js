(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{546:function(e,t,s){"use strict";s.r(t);var r=s(2),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),s("p",[e._v("源码阅读可能会迟到，但是一定不会缺席！")]),e._v(" "),s("p",[e._v("众所周知，以下代码就是 vue 的一种直接上手方式。通过 cdn 可以在线打开 vue.js。一个文件，一万行源码，能让万千开发者赖以生存，它究竟做了什么？让人品味。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("<html>\n<head></head>\n<body>\n    <div id=\"app\">\n        {{ message }}\n    </div>\n</body>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"><\/script>\n<script>\n    var app = new Vue({\n        el: '#app',\n        data: {\n            message: 'See Vue again!'\n        },\n    })\n<\/script>\n</html>\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br")])]),s("p",[e._v("源码cdn地址："),s("a",{attrs:{href:"https://cdn.jsdelivr.net/npm/vue/dist/vue.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://cdn.jsdelivr.net/npm/vue/dist/vue.js"),s("OutboundLink")],1),e._v("，当下版本：v2.6.11")]),e._v(" "),s("p",[e._v("选择生啃的原因是，自认为已经有一定的基础，且可以更自主地选择代码段分轻重来阅读，一方面测试自己的掌握程度，一方面追求更直观的源码阅读。")]),e._v(" "),s("p",[e._v("当然你也可以选择在 "),s("a",{attrs:{href:"https://github.com/vuejs/vue/tree/dev/src",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/vuejs/vue/tree/dev/src"),s("OutboundLink")],1),e._v(" 分模块的阅读，也可以看各路大神的归类整理。")]),e._v(" "),s("p",[e._v("笔者尽量按 500 行作为一个模块来形成一个 md 文件，结合注释、自己的理解、以及附上对应查询链接来逐行细读源码。")]),e._v(" "),s("p",[e._v("目的：自我梳理，分享交流。")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc1.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（1/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc2.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（2/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc3.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（3/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc4.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（4/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc5.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（5/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc6.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（6/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc7.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（7/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc8.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（8/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc9.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（9/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc10.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（10/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc11.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（11/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc12.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（12/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc13.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（13/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc14.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（14/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc15.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（15/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc16.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（16/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc17.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（17/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc18.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（18/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc19.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（19/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc20.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（20/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc20.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（21/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc20.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（22/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc20.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（23/24）"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tuaran.github.io/views/2020/studyVuesc20.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js v2.6.11 生啃一万行源码（24/24）"),s("OutboundLink")],1)])]),e._v(" "),s("h2",{attrs:{id:"正文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[e._v("#")]),e._v(" 正文")]),e._v(" "),s("h3",{attrs:{id:"第-1570-行至第-1754-行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第-1570-行至第-1754-行"}},[e._v("#")]),e._v(" 第 1570 行至第 1754 行")]),e._v(" "),s("ul",[s("li",[e._v("resolveAsset// resolveAsset 全局注册组件用到")])]),e._v(" "),s("p",[e._v("e.g.")]),e._v(" "),s("p",[e._v("我们的调用 resolveAsset(context.$options, 'components', tag)，即拿 vm.$options.components[tag]，这样我们就可以在 resolveAsset 的时候拿到这个组件的构造函数，并作为 createComponent 的钩子的参数。")]),e._v(" "),s("ul",[s("li",[e._v("validateProp// prop的格式校验")])]),e._v(" "),s("p",[e._v("校验prop：")]),e._v(" "),s("ol",[s("li",[e._v("prop为Boolean类型时做特殊处理")]),e._v(" "),s("li",[e._v("prop的值为空时，获取默认值，并创建观察者对象")]),e._v(" "),s("li",[e._v("prop验证")])]),e._v(" "),s("ul",[s("li",[e._v("getPropDefaultValue// 获取默认 prop 值")])]),e._v(" "),s("p",[e._v("获取 prop 的默认值 && 创建观察者对象")]),e._v(" "),s("ol",[s("li",[e._v("@param {*} vm vm 实例")]),e._v(" "),s("li",[e._v("@param {*} prop 定义选项")]),e._v(" "),s("li",[e._v("@param {*} vmkey prop 的 key")])]),e._v(" "),s("p",[e._v("// 在非生产环境下（除去 Weex 的某种情况），将对prop进行验证，包括验证required、type和自定义验证函数。")]),e._v(" "),s("ul",[s("li",[e._v("assertProp //验证 prop\nAssert whether a prop is valid.")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("case 1: 验证 required 属性\n   case 1.1: prop 定义时是 required，但是调用组件时没有传递该值（警告）\n   case 1.2: prop 定义时是非 required 的，且 value === null || value === undefined（符合要求，返回）\ncase 2: 验证 type 属性-- value 的类型必须是 type 数组里的其中之一\ncase 3: 验证自定义验证函数\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("ul",[s("li",[e._v("assertType")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("`assertType`函数，验证`prop`的值符合指定的`type`类型，分为三类：\n  - 第一类：通过`typeof`判断的类型，如`String`、`Number`、`Boolean`、`Function`、`Symbol`\n  - 第二类：通过`Object.prototype.toString`判断`Object`/`Array`\n  - 第三类：通过`instanceof`判断自定义的引用类型\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("h3",{attrs:{id:"第-1756-行至第-1823-行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第-1756-行至第-1823-行"}},[e._v("#")]),e._v(" 第 1756 行至第 1823 行")]),e._v(" "),s("p",[e._v("// 辅助函数：检测内置类型")]),e._v(" "),s("ul",[s("li",[e._v("getType")]),e._v(" "),s("li",[e._v("isSameType")]),e._v(" "),s("li",[e._v("getTypeIndex")]),e._v(" "),s("li",[e._v("getInvalidTypeMessage")]),e._v(" "),s("li",[e._v("styleValue")]),e._v(" "),s("li",[e._v("isExplicable")]),e._v(" "),s("li",[e._v("isBoolean")])]),e._v(" "),s("h3",{attrs:{id:"第-1827-行至第-1901-行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第-1827-行至第-1901-行"}},[e._v("#")]),e._v(" 第 1827 行至第 1901 行")]),e._v(" "),s("p",[e._v("// 辅助函数：处理错误、错误打印")]),e._v(" "),s("ul",[s("li",[e._v("handleError")]),e._v(" "),s("li",[e._v("invokeWithErrorHandling")]),e._v(" "),s("li",[e._v("globalHandleError")]),e._v(" "),s("li",[e._v("logError")])]),e._v(" "),s("h3",{attrs:{id:"第-1905-行至第-2007-行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第-1905-行至第-2007-行"}},[e._v("#")]),e._v(" 第 1905 行至第 2007 行")]),e._v(" "),s("ul",[s("li",[e._v("flushCallbacks// flushCallbacks 挨个同步执行callbacks中回调")]),e._v(" "),s("li",[e._v("MutationObserver")]),e._v(" "),s("li",[e._v("nextTick// 把传入的 cb 回调函数用 try-catch 包裹后放在一个匿名函数中推入callbacks数组中，这么做是因为防止单个 cb 如果执行错误不至于让整个JS线程挂掉，每个 cb 都包裹是防止这些回调函数如果执行错误不会相互影响，比如前一个抛错了后一个仍然可以执行。")])]),e._v(" "),s("p",[s("strong",[e._v("精髓中的精髓 —— nextTick")])]),e._v(" "),s("p",[e._v("这里有一段很重要的注释")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\n\n在vue2.5之前的版本中，nextTick基本上基于 micro task 来实现的，但是在某些情况下 micro task 具有太高的优先级，并且可能在连续顺序事件之间（例如＃4521，＃6690）或者甚至在同一事件的事件冒泡过程中之间触发（＃6566）。但是如果全部都改成 macro task，对一些有重绘和动画的场景也会有性能影响，如 issue #6813。vue2.5之后版本提供的解决办法是默认使用 micro task，但在需要时（例如在v-on附加的事件处理程序中）强制使用 macro task。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br")])]),s("p",[e._v("什么意思呢？分析下面这段代码。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("<span id='name' ref='name'>{{ name }}</span>\n<button @click='change'>change name</button>\n\nmethods: {\n      change() {\n          this.$nextTick(() => console.log('setter前：' + this.$refs.name.innerHTML))\n          this.name = ' vue3 '\n          console.log('同步方式：' + this.$refs.name.innerHTML)\n          setTimeout(() => this.console(\"setTimeout方式：\" + this.$refs.name.innerHTML))\n          this.$nextTick(() => console.log('setter后：' + this.$refs.name.innerHTML))\n          this.$nextTick().then(() => console.log('Promise方式：' + this.$refs.name.innerHTML))\n      }\n  }\n//同步方式：vue2\n//setter前：vue2\n//setter后： vue3 \n//Promise方式： vue3 \n//setTimeout方式： vue3 \n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br")])]),s("ol",[s("li",[e._v("同步方式： 当把data中的name修改之后，此时会触发name的 setter 中的 dep.notify 通知依赖本data的render watcher去 update，update 会把 flushSchedulerQueue 函数传递给 nextTick，render watcher在 flushSchedulerQueue 函数运行时 watcher.run 再走 diff -> patch 那一套重渲染 re-render 视图，这个过程中会重新依赖收集，这个过程是异步的；所以当我们直接修改了name之后打印，这时异步的改动还没有被 patch 到视图上，所以获取视图上的DOM元素还是原来的内容。")]),e._v(" "),s("li",[e._v("setter前： setter前为什么还打印原来的是原来内容呢，是因为 nextTick 在被调用的时候把回调挨个push进callbacks数组，之后执行的时候也是 for 循环出来挨个执行，所以是类似于队列这样一个概念，先入先出；在修改name之后，触发把render watcher填入 schedulerQueue 队列并把他的执行函数 flushSchedulerQueue 传递给 nextTick ，此时callbacks队列中已经有了 setter前函数 了，因为这个 cb 是在 setter前函数 之后被push进callbacks队列的，那么先入先出的执行callbacks中回调的时候先执行 setter前函数，这时并未执行render watcher的 watcher.run，所以打印DOM元素仍然是原来的内容。")]),e._v(" "),s("li",[e._v("setter后： setter后这时已经执行完 flushSchedulerQueue，这时render watcher已经把改动 patch 到视图上，所以此时获取DOM是改过之后的内容。")]),e._v(" "),s("li",[e._v("Promise方式： 相当于 Promise.then 的方式执行这个函数，此时DOM已经更改。")]),e._v(" "),s("li",[e._v("setTimeout方式： 最后执行macro task的任务，此时DOM已经更改。")])]),e._v(" "),s("p",[e._v("备注：前文提过，在依赖收集原理的响应式化方法 defineReactive 中的 setter 访问器中有派发更新 dep.notify() 方法，这个方法会挨个通知在 dep 的 subs 中收集的订阅自己变动的 watchers 执行 update。")]),e._v(" "),s("p",[e._v("强烈推荐阅读："),s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/55423103",target:"_blank",rel:"noopener noreferrer"}},[e._v("link"),s("OutboundLink")],1)]),e._v(" "),s("h3",{attrs:{id:"_0-行-至-2000-行小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0-行-至-2000-行小结"}},[e._v("#")]),e._v(" 0 行 至 2000 行小结")]),e._v(" "),s("p",[e._v("0 至 2000 行主要的内容是：")]),e._v(" "),s("ol",[s("li",[e._v("工具代码")]),e._v(" "),s("li",[e._v("数据监听：Obeserve,Dep")]),e._v(" "),s("li",[e._v("Vnode")]),e._v(" "),s("li",[e._v("nextTick")])])])}),[],!1,null,null,null);t.default=n.exports}}]);