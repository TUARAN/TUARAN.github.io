(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{554:function(e,t,n){"use strict";n.r(t);var a=n(2),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("本文首发在我的博客："),n("a",{attrs:{href:"https://tuaran.github.io/series/fe-weekly/wd202035.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端阿瓜每周速记（2020 第 35 周）"),n("OutboundLink")],1)]),e._v(" "),n("Boxx"),e._v(" "),n("p",[e._v("周记可能会迟到，但是一定不会缺席。前段时间因为一些变动（后续找机会说明），没有时间来发布。本瓜也通过这件事情来反省自己的执行力。")]),e._v(" "),n("p",[e._v("怎么说呢？诸君顺利！下面来看下 35 周速记！")]),e._v(" "),n("h2",{attrs:{id:"接口长时间-pending-是为什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#接口长时间-pending-是为什么"}},[e._v("#")]),e._v(" 接口长时间 pending 是为什么？")]),e._v(" "),n("p",[e._v("本周在实际开发中出现了一个问题，前端请求已经发出，后端说没有收到请求，查看请求又是 pending 状态，后续的请求也都是 pending ，那么请求卡在哪儿呢？")]),e._v(" "),n("p",[e._v("了解后发现，原因通常有以下三点：")]),e._v(" "),n("ol",[n("li",[e._v("后台有断点。")]),e._v(" "),n("li",[e._v("数据库修改了东西，没有提交，记录处于锁定状态，这样我们操作这个记录如修改，将不会返回。")]),e._v(" "),n("li",[e._v("前端调用接口是按照异步方式处理，在没得到后台返回前，请求是被挂起的。额外提一点：你明白 ajax 的 async:false 设置吗？")])]),e._v(" "),n("p",[e._v("按照原因就可以快速定位问题啦。最后查明是第二点所致。")]),e._v(" "),n("p",[e._v("在实际的接口对接场景中，往往会出现一些问题处在灰色地带，前端以为是后端的锅，后端以为是前端的锅，导致解决起来不顺利。")]),e._v(" "),n("p",[e._v("所以，有一个比较广的技术面，能一下指出问题是否责任唯一非常重要。")]),e._v(" "),n("p",[e._v("这个问题结束了吗？并没有。")]),e._v(" "),n("h3",{attrs:{id:"http-status"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#http-status"}},[e._v("#")]),e._v(" Http Status")]),e._v(" "),n("p",[e._v("这里想说的不是类似返回的状态码这部分内容，如需要可移步："),n("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("这里想说的是 "),n("strong",[e._v("HTTP 就绪状态")])]),e._v(" "),n("blockquote",[n("p",[e._v("HTTP 就绪状态表示请求的状态或情形。它用于确定该请求是否已经开始、是否得到了响应或者请求/响应模型是否已经完成。它还可以帮助确定读取服务器提供的响应文本或数据是否安全。")])]),e._v(" "),n("p",[e._v("我们都知道异步请求的本质是基于 "),n("strong",[e._v("XMLHttpRequest")]),e._v(" 对象，以下几个属性需要知道：")]),e._v(" "),n("ul",[n("li",[e._v("open()：建立到服务器的新请求。")]),e._v(" "),n("li",[e._v("send()：向服务器发送请求。")]),e._v(" "),n("li",[e._v("abort()：退出当前请求。")]),e._v(" "),n("li",[e._v("readyState：提供当前 HTML 的就绪状态。")]),e._v(" "),n("li",[e._v("responseText：服务器返回的请求响应文本。")])]),e._v(" "),n("p",[e._v("其中 readyState 有五种就绪状态：")]),e._v(" "),n("ul",[n("li",[e._v("0：请求没有发出（在调用 open() 之前）。")]),e._v(" "),n("li",[e._v("1：请求已经建立但还没有发出（调用 send() 之前）。")]),e._v(" "),n("li",[e._v("2：请求已经发出正在处理之中（这里通常可以从响应得到内容头部）。")]),e._v(" "),n("li",[e._v("3：请求已经处理，响应中通常有部分数据可用，但是服务器还没有完成响应。")]),e._v(" "),n("li",[e._v("4：响应已完成，可以访问服务器响应并使用它。")])]),e._v(" "),n("p",[e._v("所有状态码的第一个数字代表了响应的五种状态之一。如果不想仅停留在 AJAX 的基本知识，“readyState 每种状态出现的时机”便是你可以去拓展的地方了。")]),e._v(" "),n("p",[e._v("Q：服务器处理完请求如何告知客户端呢？")]),e._v(" "),n("p",[e._v("A：答案是 XMLHttpRequest 另一个简单属性 "),n("strong",[e._v("onreadystatechange")]),e._v("。")]),e._v(" "),n("blockquote",[n("p",[e._v("该属性允许指定一个回调函数。回调允许服务器反向调用 Web 页面中的代码。它也给了服务器一定程度的控制权，当服务器完成请求之后，会查看 XMLHttpRequest 对象，特别是 onreadystatechange 属性。然后调用该属性指定的任何方法。")])]),e._v(" "),n("p",[e._v("e.g.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function getCustomerInfo() {\n  var phone = document.getElementById("phone").value;\n  var url = "/cgi-local/lookupCustomer.php?phone=" + escape(phone);\n  request.open("GET", url, true);\n  request.onreadystatechange = updatePage; // 执行回调\n  request.send(null);\n}\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("p",[e._v("为什么要说以上的这些呢？因为我们有时候发现，状态码并不好用或不能用，更多的去了解异步请求，如就绪状态的变化，能为你提供又一个利器去解决此类问题（请求到哪了）。")]),e._v(" "),n("h3",{attrs:{id:"回顾-chrome-的-waterfall"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#回顾-chrome-的-waterfall"}},[e._v("#")]),e._v(" 回顾 Chrome 的 Waterfall")]),e._v(" "),n("ul",[n("li",[n("p",[n("strong",[e._v("Queueing")]),e._v(". 出现下面的情况时，浏览器会把当前请求放入队列中进行排队")]),e._v(" "),n("ul",[n("li",[e._v("有更高优先级的请求时.")]),e._v(" "),n("li",[e._v("和目标服务器已经建立了6个TCP连接（最多6个，适用于HTTP/1.0和HTTP/1.1）")]),e._v(" "),n("li",[e._v("浏览器正在硬盘缓存上简单的分配空间")])])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Stalled")]),e._v(". 请求会因为上面的任一个原因而阻塞。")])]),e._v(" "),n("li",[n("p",[e._v("DNS Lookup. 浏览器起正在解析IP地址。")])]),e._v(" "),n("li",[n("p",[e._v("Proxy negotiation. 浏览器正在与代理服务器协商请求。")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Request sent")]),e._v(". 正在发送请求。")])]),e._v(" "),n("li",[n("p",[e._v("ServiceWorker Preparation. 浏览器正在启动服务程序。")])]),e._v(" "),n("li",[n("p",[e._v("Request to ServiceWorker. 该请求发送给 service worker。")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Waiting (TTFB)")]),e._v(". 浏览器等待响应第一个字节到达的时间，包含来回的延迟时间和服务器准备响应的时间。")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Content Download")]),e._v(". 浏览器正在接收响应。")])]),e._v(" "),n("li",[n("p",[e._v("Receiving Push. 浏览器接收推送的数据。")])]),e._v(" "),n("li",[n("p",[e._v("Reading Push. 浏览器正在读取之前收到的本地数据。")])]),e._v(" "),n("li",[n("p",[e._v("DNS Lookup - 在浏览器和服务器进行通信之前, 必须经过DNS查询, 将域名转换成IP地址. 在这个阶段, 你可以处理的东西很少. 但幸运的是, 并非所有的请求都需要经过这一阶段.")])]),e._v(" "),n("li",[n("p",[e._v("Initial Connection - 在浏览器发送请求之前, 必须建立TCP连接. 这个过程仅仅发生在瀑布图中的开头几行, 否则这就是个性能问题(后边细说).")])]),e._v(" "),n("li",[n("p",[e._v("SSL/TLS Negotiation - 如果你的页面是通过SSL/TLS这类安全协议加载资源, 这段时间就是浏览器建立安全连接的过程. 目前Google将HTTPS作为其 搜索排名因素 之一, SSL/TLS 协商的使用变得越来越普遍了.")])]),e._v(" "),n("li",[n("p",[e._v("Time To First Byte (TTFB) - TTFB 是浏览器请求发送到服务器的时间+服务器处理请求时间+响应报文的第一字节到达浏览器的时间. 我们用这个指标来判断你的web服务器是否性能不够, 或者说你是否需要使用CDN.")])]),e._v(" "),n("li",[n("p",[e._v("Downloading - 这是浏览器用来下载资源所用的时间. 这段时间越长, 说明资源越大. 理想情况下, 你可以通过控制资源的大小来控制这段时间的长度.")])])]),e._v(" "),n("p",[e._v("查看更多："),n("a",{attrs:{href:"https://developers.google.com/web/tools/chrome-devtools/network/reference#timing-explanation",target:"_blank",rel:"noopener noreferrer"}},[e._v("timing-explanation - developers.google.com"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"vuex-plugin"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vuex-plugin"}},[e._v("#")]),e._v(" vuex plugin")]),e._v(" "),n("p",[e._v("显然，Vuex plugin 没有另外几个核心模块（State、Getters、Mutations、Actions、Modules）来的亮眼，使用频率也没那么高。")]),e._v(" "),n("p",[e._v("但它也真的不容错过！")]),e._v(" "),n("blockquote",[n("p",[e._v("通过 Vuex 插件可以非常容易的扩展一些很酷的功能。Vuex 社区中的开发人员已经创建了大量的免费插件供你使用，有许多你能想象的功能，还有一些你可能没有想到的功能。")])]),e._v(" "),n("p",[e._v("比如：状态持久化，同步标签页、窗口，语言本地化，管理多个加载状态，缓存操作等。"),n("a",{attrs:{href:"https://vuejsdevelopers.com/2017/09/11/vue-js-vuex-plugins/?jsdojo_id=medium_vpl",target:"_blank",rel:"noopener noreferrer"}},[e._v("实践"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("原理：")]),e._v(" "),n("p",[e._v("Vuex 的 store 接受 plugins 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数：")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const myPlugin = store => {\n  // 当 store 初始化后调用\n  store.subscribe((mutation, state) => {\n    // 每次 mutation 之后调用\n    // mutation 的格式为 { type, payload }\n  })\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("p",[e._v("然后像这样使用：")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const store = new Vuex.Store({\n  // ...\n  plugins: [myPlugin]\n})\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("h3",{attrs:{id:"_5-个常用-plugin-插件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-个常用-plugin-插件"}},[e._v("#")]),e._v(" 5 个常用 plugin 插件")]),e._v(" "),n("ol",[n("li",[e._v("状态持久化："),n("a",{attrs:{href:"https://github.com/robinvdvleuten/vuex-persistedstate",target:"_blank",rel:"noopener noreferrer"}},[e._v("vuex-persistedstate"),n("OutboundLink")],1),e._v(" 再也不用担心刷新后状态被清除啦。")]),e._v(" "),n("li",[e._v("同步标签页和窗口："),n("a",{attrs:{href:"https://github.com/xanf/vuex-shared-mutations",target:"_blank",rel:"noopener noreferrer"}},[e._v("vuex-shared-mutations"),n("OutboundLink")],1)]),e._v(" "),n("li",[e._v("语言本地化："),n("a",{attrs:{href:"https://github.com/dkfbasel/vuex-i18n",target:"_blank",rel:"noopener noreferrer"}},[e._v("vuex-i18n"),n("OutboundLink")],1)]),e._v(" "),n("li",[e._v("管理多个加载状态："),n("a",{attrs:{href:"https://github.com/f/vue-wait",target:"_blank",rel:"noopener noreferrer"}},[e._v("vuex-loading"),n("OutboundLink")],1)]),e._v(" "),n("li",[e._v("缓存操作："),n("a",{attrs:{href:"https://github.com/superwf/vuex-cache",target:"_blank",rel:"noopener noreferrer"}},[e._v("vuex-cache"),n("OutboundLink")],1)])]),e._v(" "),n("p",[n("a",{attrs:{href:"https://segmentfault.com/a/1190000012184535",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"其它"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其它"}},[e._v("#")]),e._v(" 其它")]),e._v(" "),n("h3",{attrs:{id:"文章分享"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#文章分享"}},[e._v("#")]),e._v(" 文章分享")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2011/10/dont_call_yourself_a_programmer.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("不要自称为程序员"),n("OutboundLink")],1)])]),e._v(" "),n("p",[e._v("九年前的一篇文章，比较有感触的不是“不要自称为程序员”，而是“90%的编程工作来自内部软件”。")]),e._v(" "),n("p",[e._v("目前，大部分的程序员的工作还是偏内部项目或者2B端多一点吧，这些项目的确或多或少存在文中所述问题。")]),e._v(" "),n("p",[e._v("但是改变不想接受的，接受不能改变的。当下，我们能做的是：自我要求。把项目做好，也能有面向大众机会。")]),e._v(" "),n("h3",{attrs:{id:"chrome只能创建6个tcp连接"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#chrome只能创建6个tcp连接"}},[e._v("#")]),e._v(" chrome只能创建6个TCP连接？")]),e._v(" "),n("p",[e._v("Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。")]),e._v(" "),n("h3",{attrs:{id:"关于package-json中dependencies和devdependencies的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关于package-json中dependencies和devdependencies的区别"}},[e._v("#")]),e._v(" 关于package.json中dependencies和Devdependencies的区别")]),e._v(" "),n("p",[e._v("dependencies是生产环境所需要的依赖如vue，elementUI，axios等。")]),e._v(" "),n("p",[e._v("而Devdependencies是开发环境所需要的依赖如webpack，babel-loader等。Devdependencies只存在与开发阶段，也就是说项目打包过后不会用到这些依赖。")]),e._v(" "),n("p",[e._v("另附 package-lock.json：是当 node_modules 或 package.json 发生变化时自动生成的文件。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。")]),e._v(" "),n("p",[e._v("另附 npm 如何安装到固定版本：")]),e._v(" "),n("p",[e._v("npm install vue-template-compiler@2.6.10")]),e._v(" "),n("h3",{attrs:{id:"推荐阅读"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#推荐阅读"}},[e._v("#")]),e._v(" 推荐阅读")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://www.ibm.com/developerworks/cn/xml/wa-ajaxintro2/",target:"_blank",rel:"noopener noreferrer"}},[e._v("使用 JavaScript 和 Ajax 发出异步请求 -\tBrett McLaughlin"),n("OutboundLink")],1)])],1)}),[],!1,null,null,null);t.default=r.exports}}]);